import queue
import random
import string
import threading
import time


class SMSSimulation:
    """
    Class to simulate sending SMS messages. The simulation consists of a producer that generates messages and puts them
    in a queue. Senders take messages from the queue and sends them. The simulation also has a progress monitor that
    monitors the progress of the simulation.
    """

    def __init__(self, message_count, message_queue, senders_count, sender_processing_times, sender_failure_rates,
                 progress_monitor_update_interval):
        """
        Initializes the SMSSimulation with configurable parameters.
        :param message_count: the total number of messages to be generated
        :param message_queue: the message queue to be used for the simulation
        :param senders_count: the number of senders to be created
        :param sender_processing_times: the mean processing time for each sender
        :param sender_failure_rates: the failure rate for each sender
        :param progress_monitor_update_interval:  the time in seconds the progress monitor should wait before printing the progress
        """
        self.message_queue = message_queue
        self.message_count = message_count
        self.senders_count = senders_count
        self.sender_processing_times = sender_processing_times
        self.sender_failure_rates = sender_failure_rates
        self.progress_monitor_update_interval = progress_monitor_update_interval

        # variables to track the simulation progress
        self.success_messages = 0
        self.failed_messages = 0
        self.total_processing_time = 0

        self.lock = threading.Lock()

    def generate_random_message(self):
        """
        Function generates a random messages of length up to 100 characters by randomly selecting characters in
        string.ascii_letters, string.digits, string.punctuation and string.Whitespace in a random order. Returns a
        string with the generated message.
        """
        message_length = random.randint(1, 100)
        random_chars = [random.choice(string.ascii_letters + string.digits + string.punctuation + string.whitespace)
                        for _ in range(message_length)]
        return ''.join(random_chars)


    def producer(self):
        """
        Producer function to generate messages and put them in the message queue. The number of messages is defined by
        the message_count variable that is configurable.
        """
        for _ in range(self.message_count):
            message = self.generate_random_message()
            self.message_queue.put(message)

    def sender(self, processing_mean_time, failure_rate):
        """
        Sender function that simulates sending messages.
        :param processing_mean_time: the mean time taken to process a message
        :param failure_rate: the failure rate of the sender
        """
        while not self.message_queue.empty():
            # removes a message from the queue that is to be sent. This can be stored into a variable that can be used
            # with an API to send the message. In this case we are just simulating and hence need not store the message.
            self.message_queue.get()
            # Mark the message as processed by notifying the queue
            self.message_queue.task_done()

            start_time = time.time()
            # The waiting time is generated by using gaussian distribution with a mean of mean_time and a standard
            # deviation of 0.1. This will result in the waiting time being distributed around the configurable
            # mean_time. max is used to ensure that the waiting time is not negative
            waiting_time = max(0, random.gauss(processing_mean_time, 0.1))
            time.sleep(waiting_time)
            end_time = time.time()

            # Simulate a random failure rate by generating a random number between 0 and 1 and comparing it
            if random.random() < failure_rate:
                with self.lock:
                    self.failed_messages += 1
            else:
                with self.lock:
                    self.success_messages += 1
                    self.total_processing_time += end_time - start_time

    def progress_monitor(self):
        """
        Progress monitor function that monitors the progress of the simulation. It prints the number of messages sent,
        failed, and the average time taken to process a message.
        """
        while not self.message_queue.empty():
            # The progress monitor sleeps for the configurable update interval and prints the progress of the simulation
            time.sleep(self.progress_monitor_update_interval)
            with self.lock:
                # The average processing time is the time spent on processing the successful and failed messages
                avg_processing_time = self.total_processing_time / (self.success_messages + self.failed_messages)
                print(
                    f"Messages sent: {self.success_messages}, Messages failed: {self.failed_messages}, Avg Time per message: {avg_processing_time:.2f} seconds")

    def run_simulation(self):
        """
        Function to run the simulation. It creates a producer thread to generate messages, configurable number of
        sender threads to send messages, and a progress monitor thread to monitor the progress of the simulation.
        """
        # Creating a producer thread to generate messages
        producer_thread = threading.Thread(target=self.producer)
        producer_thread.start()

        # Creating configurable number of sender threads to send messages. It is configured through the senders_count.
        sender_threads = []
        for i in range(senders_count):
            sender_thread = threading.Thread(target=self.sender,
                                             args=(self.sender_processing_times[i], self.sender_failure_rates[i]))
            sender_threads.append(sender_thread)
            sender_thread.start()

        # Creating a progress monitor thread to monitor the progress of the simulation
        progress_monitor_thread = threading.Thread(target=self.progress_monitor)
        progress_monitor_thread.start()

        # Wait for all the threads to finish
        producer_thread.join()
        for sender_thread in sender_threads:
            sender_thread.join()
        progress_monitor_thread.join()

    def set_simulation_variable_for_testing(self, success_messages, failed_messages, total_processing_time):
        """
        Function to set the simulation variables for testing purposes.
        :param success_messages: Success messages count to be set.
        :param failed_messages: Failed messages count to be set.
        :param total_processing_time: Total processing time to be set.
        """
        self.success_messages = success_messages
        self.failed_messages = failed_messages
        self.total_processing_time = total_processing_time


if __name__ == "__main__":
    message_count = 1000  # total number of messages to be generated
    senders_count = 5  # total number of senders to be created
    sender_processing_times = [0.2, 0.3, 0.4, 0.5, 0.6]  # every sender has a different processing time
    sender_failure_rates = [0.05, 0.1, 0.15, 0.2, 0.25]  # every sender has a different failure rate
    progress_monitor_update_interval = 5  # time in seconds the progress monitor should wait before printing the progress
    message_queue = queue.Queue()

    simulation = SMSSimulation(message_count, message_queue, senders_count, sender_processing_times,
                               sender_failure_rates, progress_monitor_update_interval)
    simulation.run_simulation()
